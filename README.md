# آزمایش سوم -  آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: علیرضا حیدری 98109731، حمیدرضا یعقوبی 98109786
## گزارش مراحل انجام آزمایش
ابتدا مشابه شکل زیر، کتاب خانه junit را نصب می کنیم.
![Screenshot from 2023-11-20 23-17-42](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/35f584c6-b848-490b-8ee3-d19dd6357093)
![Screenshot from 2023-11-20 23-18-31](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/9ed6a95b-dbb3-454d-9f00-44d4a7f32172)
سپس در یک برنچ مشخص، به گونه‌ای که صرفا خطای کامپایل نگیریم،‌کلاس مستطیل را پیاده سازی می‌کنیم.
![Screenshot from 2023-11-20 23-11-52](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/b70f2ac4-ab76-4f3a-a7cf-fa3d03896dd8)

حال تست را پیاده سازی میکنیم
![Screenshot from 2023-11-20 23-21-51](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/65668693-daf6-46d7-81bc-d10e3ceb3482)
و خب ارور دریافت می کنیم. حال توابع را پیاده سازی می کنیم

![Screenshot from 2023-11-21 08-59-20](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/2bb63c70-edbe-42bf-a1d4-4599989b59d7)
![Screenshot from 2023-11-21 08-59-30](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/ae15290d-0981-4d13-a860-7ae139484259)
و ارور ها برطرف می شود.
حال توابع گتر و ستر را صرفا در حدی که مشکل نخورد پیاده سازی میکنیم. تست هارو ران می کنیم و مشاهده می کنیم که تست ها پاس نمی شود. حال توابع را پیاده سازی میکنیم و مشاهده می کنیم که تست ها پاس می شود.

![Screenshot from 2023-11-21 09-07-33](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/b841f8ee-b2a9-49f4-952a-38bdbbb20ef1)
![Screenshot from 2023-11-21 09-07-41](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/e7416c44-98d0-495d-82c4-fe28c7e38e6f)
![Screenshot from 2023-11-21 09-09-41](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/baa741c7-752f-4999-9d08-7c95a21a825c)
![Screenshot from 2023-11-21 09-09-45](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/f8d01bd1-3f2f-404f-86bf-28f53c29cd29)

## پرسش‌ها

### پرسش یک
در واقع مسئله‌ در این سوال، نحوه رسیدن به هدف است. به صورت کلی هدف از نوشتن تست و اجرای آن، مطمعن شدن از نحوه صحیح اجرای برنامه است. در واقع هدف اجرای صحیح برنامه است و برای رسیدن به آن هدف های مختلفی وجود دارد. در روش های سنتی، پس از نوشتن برنامه آنها را تست می کردیم تا مطمعن شویم که آنها به درستی کار میکنند. اما اتفاقی که میتونست بیوفته این بود که مثلا متوجه میشدیم که نکته ای را در نظر نگرفتیم و برمی گشتیم و کد را تغییر می دادیم. به مرور زمان این کار باعث میشد maintenance آن سخت شود. یا حتی ممکن بود بعد از تست هم متوجه بشوی که همه چیز را تست نکردیم. که این موضوع قضیه را حتی سخت تر هم می کرد. اما در رویکرد TDD ابتدا خواسته خود را به طور دقیق مشخص می کردیم و سپس برای آن کد می نوشتیم. این کار باعث میشود که هزینه پیاده سازی و نگه داری کد کمتر باشد.
### پرسش دو
![Screenshot from 2023-11-22 18-44-45](https://github.com/hamidrezayaghobi/SEL_week3/assets/59170724/c796eb07-20a5-407c-b591-824cd046ca45)
شمل بالا کامل گویا قضیه است. در واقع هرچه ریزدانگی تست ها کمتر میشود، یا به عبارتی هرچی تست ها بزرگ تر میشود، جنبه کلی تری از برنامه را بررسی می کند و معمولا هزینه پیاده سازی و تست بیشتری را دارند. 

### پرسش سه
مشخصا نه. اصلا در شرکت های بزرگ، کارها و پروژه ها به تسک های خیلی کوچیکی تقسیم میشه که هر تسک رو یک نفر انجام میده. به همین خاطر اصلا یک نفر ممکن هستش که سوپرویژن لازم برای تست کردن یک برنامه یا یک پروژه را نداشته باشید. به همین خاطر است که در اکثر شرکت های بزرگ، ما واحدی تحت عنوان QA داریم.

### پرسش چهار

تحلیل نیازمندی‌ها: در این مرحله، تمرکز بر روی شناسایی و تعریف نیازمندی‌های سیستم است. اصول SOLID معمولاً به‌طور مستقیم در این مرحله به کار گرفته نمی‌شوند، زیرا این اصول بیشتر با جنبه‌های فنی و ساختاری کدسازی سروکار دارند.

طراحی: این مرحله کلیدی برای اعمال اصول SOLID است. در طراحی، معماری و ساختار نرم‌افزار مشخص می‌شود. استفاده از اصول SOLID در این مرحله به ایجاد یک طراحی منعطف، قابل نگهداری و گسترش‌پذیر کمک می‌کند. برای مثال، اصل Single Responsibility (مسئولیت واحد) به تعریف کلاس‌ها و ماژول‌ها با مسئولیت‌های مشخص و محدود کمک می‌کند.

پیاده‌سازی: اصول SOLID در این مرحله برای نوشتن کد کاربردی و موثر استفاده می‌شوند. به عنوان مثال، اصل Liskov Substitution (جایگزینی لیسکوف) راهنمایی می‌کند که چگونه وراثت و پیاده‌سازی رابط‌ها باید به گونه‌ای انجام شود که کد قابلیت انتقال و جایگزینی داشته باشد.

آزمون: در حین آزمون، کد نوشته شده بررسی می‌شود تا اطمینان حاصل شود که به درستی کار می‌کند و نیازمندی‌های تعریف شده را برآورده می‌سازد. اگرچه اصول SOLID مستقیماً در فرایند آزمون به کار گرفته نمی‌شوند، اما کدی که بر اساس این اصول نوشته شده باشد، معمولاً آزمون‌پذیرتر و قابلیت نگهداری بیشتری دارد.

استقرار: در مرحله استقرار، نرم‌افزار در محیط‌های هدف پیاده‌سازی می‌شود. اصول SOLID در این مرحله نیز به‌طور مستقیم کاربرد ندارند، ولی نرم‌افزاری که بر اساس این اصول طراحی و پیاده‌سازی شده باشد، ممکن است نگهداری و بروزرسانی‌های بعدی را ساده‌تر کند.

### پرسش پنج

در حالت کلی, پیشنهاد می‌شود که کلاس مربع به صورت مستقل تعریف شود و از کلاس مستطیل به عنوان پایه استفاده نگردد یا هر دو از یک موجودیت abstract تر ارث بری کنند.

در مورد مسئله ارث بری مربع از مستطیل، یکی از پیشنهادات برای جلوگیری از بروز مشکل این است که فرض کنیم شکل‌ها پس از ساخته شدن قابلیت تغییر ندارند. به این صورت، هر تغییری در یک شکل به معنای خلق شکل جدیدی است و امکان دگرگونی ابعاد شکل فعلی وجود نخواهد داشت. این فرضیه مشکلی را که در مثال مطرح شده (تغییر مکرر ابعاد مربع) حل می‌کند و امکان ارث بری منطقی مربع از مستطیل را فراهم می‌آورد.




